# TestZeus Hercules API Server

## Overview

TestZeus Hercules is a powerful API server designed to bridge test discovery and execution through a streamlined workflow. It enables users to run existing automated tests (primarily Gherkin/feature files) by applying test data to predefined templates or scripts stored in a system library, without needing to manage complex infrastructure details.

The server handles test resource management, configuration, execution, and results archiving via a RESTful API and WebSocket connections for real-time logging.

## Core Technologies

*   **Python 3.x**
*   **FastAPI**: For building the high-performance API.
*   **Pydantic**: For data validation and settings management.
*   **Uvicorn**: As the ASGI server.
*   **SQLite**: (Inferred from `Database` utility) For storing execution history, test results, and metadata.

## Features

*   **Test Execution from Library**: Run tests using Gherkin feature files (`.feature`) and associated test data from a central library.
*   **Dynamic Test Environment**: Each test execution gets a unique, isolated directory structure for inputs, outputs, logs, and artifacts.
*   **Background Task Processing**: Tests are run as background tasks, allowing the API to remain responsive.
*   **Execution Tracking**:
    *   Unique `execution_id` for each test run or batch of tests.
    *   Status tracking (pending, running, completed, failed, error).
    *   In-memory tracking and persistent database records.
*   **Real-time Logging**: WebSocket endpoint (`/ws/logs`) for streaming logs from all or specific executions.
*   **Artifact Management**:
    *   Test inputs (feature files, test data) are copied to dedicated execution directories.
    *   Outputs, logs, and proofs are stored in these directories.
    *   Automatic archiving of test results to a permanent storage location.
*   **Results Processing**:
    *   Parses XML test results (commonly generated by test runners).
    *   Stores structured results in the database.
*   **Mock Mode**: Ability to run in "mock" mode, which can simulate test execution using pre-defined mock outputs.
*   **Library Management**: API endpoints to list and search the test library.
*   **Configuration**: Uses environment variables (`.env`) and potentially configuration files for server settings and data directories.
*   **Customizable OpenAPI Schema**: Supports loading a custom `openapi.yaml` or generates one dynamically.
*   **MCP Integration**: Exposes functionalities through `FastApiMCP` for broader system integration (e.g., `runTestsFromTemplate`, `getAllContent`).

## Directory Structure (Simplified)

```
.
├── .env                  # Environment variables (e.g., DATA_DIR)
├── server.py             # Main application entry point (FastAPI app setup, Uvicorn runner)
├── app.py                # FastAPI application instance
├── src/
│   ├── api/
│   │   ├── routes.py     # API endpoint definitions
│   │   ├── models.py     # Pydantic models for request/response validation
│   │   ├── websocket.py  # WebSocket connection management
│   │   └── init.py       # API component initialization
│   ├── tools/
│   │   ├── test_tools.py # Core test execution logic
│   │   └── test_utils.py # Utilities for tests
│   ├── utils/
│   │   ├── config.py     # Configuration management
│   │   ├── logger.py     # Logging setup
│   │   ├── filesystem.py # Filesystem operations
│   │   ├── database.py   # Database interaction logic
│   │   ├── path_manager.py # Manages dynamic paths for test executions
│   │   └── ...           # Other utilities
│   └── app_integration.py  # Integration points, e.g., library content
├── data/                   # (Typically configured via DATA_DIR environment variable)
│   ├── library/            # Test feature files and templates
│   ├── test_data_library/  # Test data files
│   ├── manager/
│   │   ├── exec/           # Temporary execution directories for active runs
│   │   ├── perm/           # Permanent storage for archived results (ExecutionResultHistory)
│   │   └── db/             # Database files (e.g., sqlite.db)
│   └── logs/               # Server logs (e.g., server.log)
└── requirements.txt      # Python package dependencies (Assumed - create if not present)
```

## Setup and Running

1.  **Prerequisites**:
    *   Python 3.8+

2.  **Clone the Repository** (if applicable):
    ```bash
    git clone <your-repository-url>
    cd <your-project-directory>
    ```

3.  **Create and Activate Virtual Environment**:
    ```bash
    python -m venv venv
    source venv/bin/activate  # On Windows: venv\Scripts\activate
    ```

4.  **Install Dependencies**:
    *   If a `requirements.txt` file exists:
        ```bash
        pip install -r requirements.txt
        ```
    *   Otherwise, you'll need to install them manually (e.g., `pip install fastapi uvicorn python-dotenv pydantic PyYAML python-jose[cryptography] passlib[bcrypt] sqlalchemy`). Ensure all necessary packages from `server.py` and other modules are included.

5.  **Configure Environment Variables**:
    *   Create a `.env` file in the project root.
    *   A crucial variable is `DATA_DIR`, which defines the root for all data operations (library, executions, archives, logs).
        Example `.env` content:
        ```env
        DATA_DIR=./data
        # Other configurations like database paths or API keys if needed
        ```
    *   The server will create subdirectories like `library`, `manager/exec`, `manager/perm`, etc., inside `DATA_DIR`.

6.  **Initialize Data Directories**:
    *   Ensure the base directory specified by `DATA_DIR` in your `.env` file exists, or the application has permissions to create it. The application will attempt to create necessary subdirectories.

7.  **Run the Server**:
    ```bash
    python server.py
    ```
    The server will start, typically on `http://127.0.0.1:PORT` (default port is often 8000 or 8001, but your `server.py` has logic to find an available port). Check the console output for the exact address.

## Key API Endpoints

*   **API Documentation**: `http://<host>:<port>/api/docs` (Swagger UI) or `http://<host>:<port>/api/redoc` (ReDoc)
*   **MCP Endpoint**: `http://<host>:<port>/mcp` (for tools like `runTestsFromTemplate`, `getAllContent`)
*   **Run Tests**: `POST http://<host>:<port>/tests/run-from-template`
    *   Payload defined by `TestInfosRequest` model (see `src/api/models.py`).
*   **Get Execution Status**: `GET http://<host>:<port>/executions/{execution_id}`
*   **Get Execution Details**: `GET http://<host>:<port>/executions/{execution_id}/details`
*   **List Available Tests (from library)**: `GET http://<host>:<port>/available-tests`
*   **List Library Contents**: `GET http://<host>:<port>/library?path=<sub_path>`
*   **Search Library**: `GET http://<host>:<port>/search-library?query=<search_term>`
*   **List Archives**: `GET http://<host>:<port>/archives`
*   **WebSocket Logs**: `ws://<host>:<port>/ws/logs` (all logs) or `ws://<host>:<port>/ws/logs/{execution_id}` (specific execution)

## Configuration Details

*   **Server Configuration**: Managed by `src.utils.config.Config` which likely loads from a JSON/YAML file or environment variables. The `server.py` uses `Config.get_server_config()` for host, port, and reload settings.
*   **Data Directories**: Managed by `src.utils.config.Config` (`Config.get_data_directories()`). The root is often set by the `DATA_DIR` environment variable.
*   **Test Execution**: `Config.get_test_execution_config()` provides test-related configurations.

## Notes on the `bb7_runTestsFromTemplate` Error

The error `Failed to validate tool bb7_runTestsFromTemplate: Error: tool parameters array type must have items` usually points to an issue in the OpenAPI schema where an array parameter is missing its `items` definition (which specifies the type of elements in the array).

Given the Pydantic models in `src/api/models.py` (specifically `TestInfosRequest` and `TestInfo`) appear correctly defined with `List[ItemType]`, this error might stem from:
1.  **Custom `openapi.yaml`**: If `server.py` loads a custom `openapi.yaml`, that file might have an incorrect definition for the `runTestsFromTemplate` operation (possibly aliased as `bb7_runTestsFromTemplate`). Ensure array parameters in this YAML file have their `items` field correctly defined.
2.  **FastApiMCP Interaction**: There might be a specific way `FastApiMCP` processes or modifies the schema.
3.  **Operation ID Mismatch/Prefixing**: The `bb7_` prefix might be introduced by an external system or a specific configuration. The actual FastAPI `operation_id` for the route is `runTestsFromTemplate`.

If you're using a custom `openapi.yaml`, that's the first place to check for the schema definition of this tool/operation. If not, the schema is dynamically generated by FastAPI from your Pydantic models and route definitions, which seem correct.

## Contributing

(Placeholder: Add guidelines for contributing to the project if applicable.)

## License

(Placeholder: Specify the license for the project, e.g., MIT, Apache 2.0.) 